---
title: "Combining Data Sets with `dplyr`"
output:
  word_document: default
  html_document: default
---

```{r message=FALSE}
library(tidyverse)
library(pander)
```


## Stacking Rows

Suppose we have the following two data sets. The first, `dat1` has the variables `x1` and `y1`. The second, `dat2` has the same variables. They represent a pair of datasets measuring the same features at two different locations. We would like to combine them into a single data frame.

```{r, echo=TRUE}
# generating fake data for us to use for the rest of this project
dat1 <- tibble(x1 = runif(4),
  y1 = rnorm(4))
dat2 <- tibble(y1 = rpois(4,1),
              x1 = rgamma(4,shape = 2,scale = 3))

```

Notice that the order of the two variables is switched in the two tibbles. This means we can't simply stack them without matching column headings

#### `bind_rows()`

```{r}
# this allows us to combine data from different datasets
data_all <- 
bind_rows(
  "L1" = dat1, 
  "L2" = dat2,
  .id = "Location") # this allows you to specify the data that comes from each dataset
```


## Merging Data using Joins

Suppose you have the following two data sets. The first, `df1` has the variables `id_numb` and `xvar`. The second, `df2` has the variables `id` and `yvar`. `id_numb` and `id` serve as identification variables, possibly with duplicates, where observations from the first data set with `id_numb = 1` correspond to observations in the second data set with `id = 1`.

Mutating joins add columns from one dataset to another. They do this by matching rows based on keys.
  - `inner_join()` includes all rows in `x` and `y`
  - `left_join()` includes all rows in `x`
  - `right_join()` includes all rows in `y`
  - `full_join()` incluldes all rows in `x` or `y`
      - will keep all of the rows that are x but don't have a matching y and will input missing values when they can't match things up.  Will keep everything, match when it can but if not throw some missing values in there
      
      
Filtering joins filter rows from `x` based on the presence or absence of matches in `y`:
  - `semi_join()` return all rows from `x` with a match in `y` (essentially subsets the rows based on data from another dataset)
  - `anti_join()` return all rows from `x` without a match in `y`
  

```{r}
df1 <- tibble(id_numb = c(1, 1, 2, 4),
  xvar = c(16, -1, 11, 13))
df2 <- tibble(id = c(1, 2, 2, 3),
              yvar = c(-1, -4, 0, -9))
```

##### Mutating Joins

* `left_join()`
```{r}
# join df2 to df1 (via left_join)

left_join(x = df1, # will pull info from df2 into df1
          y = df2,
          by = c("id_numb" = "id") # tells R how to match these two data sets, x = y connection
            )

# join df1 to df2
left_join(x = df2,
          y = df1,
          by = c("id" = "id_numb")
          )
```


* `right_join()`
```{r}
# joining df1 to df2
right_join(x = df2,
           y = df1,
           by = c("id" = "id_numb"))

# joining df2 to df1
right_join(x = df1,
           y = df2,
           by = c("id_numb" = "id"))
```

* `inner_join()`
```{r}
inner_join(x = df2,
           y = df1,
           by = c("id" = "id_numb"))

# this can also be done with piping, here the piped data will go into the x spot
df1 %>%
  inner_join(y = df2,
             by = c("id_numb" = "id")
             )
```

* `full_join()`
```{r}
df2 %>%
full_join(x = df1,
          y = ., # can use the . to force the piped data into a specific location
          by = c("id_numb" = "id")
          )

# with the full join, it will keep all of values, match up where it can and put some NAs in where it can't
```


##### Filtering Joins

* `semi_join()`
```{r}
# using the second dataset to subset the first data set based on the rows that match the second data set, will only return the first data set though
semi_join(x = df1,
          y = df2,
          by = c("id_numb" = "id")
          )

```


* `anti_join()`
```{r}
# like a filter but a not equals kind of filter
anti_join(
  x = df1,
  y = df2,
  by = c("id_numb" = "id")
)

# the only row of df1 (x) that does not have a match in df2 (y)
```



### More Examples


1. Run the following and explain why `R` does not simply stack the rows. Then, fix the issue with the `rename()` function.

```{r}
df_test1a <- tibble(xvar = c(1, 2), yvar = c(5, 1))
df_test1b <- tibble(x = c(1, 2), y = c(5, 1))
bind_rows(df_test1a, df_test1b)
```
R does not stack the rows because the variable names in df_test1a and df_tes1b are different.  The `bind_rows()` function does not specify how to bind the rows. 
```{r}
# rename the column headers in the dataset
#df_test1a <- df_test1a %>% 
             # rename(x = xvar, y = yvar)

# bind the two datasets together
bind_rows("1a" = df_test1a,
          "1b" = df_test1b,
          .id = "Dataset")


```

Now try again (prior to renaming) using `unite`
```{r}
bind_rows(df_test1a, df_test1b) %>%
  unite(xvar, x, col = "x", sep = "", na.rm = TRUE) %>%
  unite(yvar, y, col = "y", sep = "", na.rm = TRUE)
```



Consider the `babynames` `R` package, which has the following data sets:

* `lifetables`: cohort life tables for different `sex` and different `year` variables, starting at the year 1900.
* `births`: the number of births in the United States in each year, since 1909
* `babynames`: popularity of different baby names per year and sex since the year 1880.

```{r, results = "hide", appendix = TRUE}
library(babynames)
life_df <- babynames::lifetables
birth_df <- babynames::births
babynames_df <- babynames::babynames
head(babynames)
head(births)
head(lifetables)
```

You can read about each data set with `?babynames`, `?births` and `?lifetables`.

2. Merge/Join the births data into the babynames data.
```{r}
left_join(babynames,
          births,
          by = c("year"="year"))

```

3. Merge/Join the babynames data into the births data.
```{r}
left_join(births,
          babynames,
          by = c("year"="year"))
```

4. Examine the two joins, and explain why one resulting data set has fewer observations (rows) than the other.

Joining the babynames data into the births data has fewer observations because instead of taking every year of data that is in the babynames (which starts at 1800), the births data starts at 1909 and the `left_join` function is not adding more rows into the births dataset.  Instead it is matching the data from the babynames based on the year that the births data set starts at.

5. Evaluate whether the following statement is true or false: an `inner_join()` will always result in a data set with the same or fewer rows than a `full_join()`.

This is true because the `inner_join()` will only inclue values with matches between the data.  On the other hand, the `full_join()` will include the full data from all of the observations. 

6. Evaluate whether the following statement is true or false: an `inner_join()` will always result in a data set with the same or fewer rows than a `left_join()`.

This is true because depending on how you use the `left_join()` it could only include the matches (thus generating a table with the same number of rows as `inner_join()`), or it could include more observations.  The `inner_join()` will only include the matches. 

```{r}
x = tibble(x1 = 1, y1 = 10)
y = tibble(x1 = c(1,1,2,2,3,3),
           y2 = c(7,8,4,6,7,3))

inner_join(x,y, by = "x1")
inner_join(y,x, by = "x1")

left_join(x,y, by = "x1")
left_join(y,x, by = "x1")
```


## Exercises

1. Read in the gun violence data set, and suppose that you want to add a row to this data set that has the statistics on gun ownership and mortality rate in the District of Columbia (Washington D.C., which is in the NE region, has 16.7 deaths per 100,000 people, and a gun ownership rate of 8.7%). To do so, create a `tibble()` that has a single row representing D.C. and then combine your new `tibble` with the overall gun violence data set. Name this new data set `all_df`.

```{r, message = FALSE}
library(here)
library(tidyverse)
mortality_df <- read_csv(here("data","gun_violence_us.csv"))
```

```{r, echo = FALSE, results = "hide"}
dc_df <- tibble(state = "Washington D.C.", mortality_rate = 16.7,
       ownership_rate = 0.087, region = "NE")
```

2. Explain why each attempt at combining the D.C. data with the overall data doesn't work or is incorrect.

```{r, error = TRUE, echo = TRUE, results = "hide"}
test1 <- tibble(state = "Washington D.C.", mortality_rate = 16.7,
                ownership_rate = 8.7, region = "NE") # the ownership rate is incorrect
bind_rows(mortality_df, test1)

test2 <- tibble(state = "Washington D.C.", mortality_rate = 16.7,
       ownership_rate = 0.087, region = NE) #there are no quotes around the NE
bind_rows(mortality_df, test2) #since the previous code did not work, R can't find the test2 df

test3 <- tibble(state = "Washington D.C.", mortality_rate = "16.7",
       ownership_rate = "0.087", region = "NE")
bind_rows(mortality_df, test3) # the mortality rate is in quotation marks which makes it a character. R can't add the character to a column of integer data
```

3. Examine the following data sets that are in `R`'s base library on demographic statistics about the U.S. states and state abbreviations:

```{r}
df1 <- as_tibble(state.x77)
df2 <- as_tibble(state.abb)
df1
df2
```

Combine the two data sets with `bind_cols()`. What are you assuming about the data sets in order to use this function? 

In order to use this as a function, I am assuming that the data in df1 are in alphabetical order based on the state that the data is for.
```{r}
states_df <-
bind_cols(df2, df1)
          
```


4. Use a join function to combine the mortality data set (`all_df`) __with__ D.C. with the states data set from `states_df`. For this exercise, keep the row with Washington D.C., having it take on `NA` values for any variable not observed in the states data.
```{r}
left_join(states_df, mortality_df, by = c("value"= "state") )
```


5. Repeat Exercise 4, but now drop Washington D.C. in your merging process. Practice doing this __with a join function__ (as opposed to `slice`-ing or `filter`-ing it out explicitly).
```{r}
semi_join(states_df,mortality_df, by = c("value" = "state") )
```


6. Use `semi_join()` to create a subset of `states_df` that are in the `NE` region. __Hint__: You will need to filter `all_df` first to contain only states in the `NE` region.
```{r}
mortality_df %>%
  filter(region == "NE") %>%
  semi_join(states_df,., by = c("value" = "state") )
```

7. Do the same thing as Exercise 6, but this time, use `anti_join()`. __Hint__: You'll need to filter `all_df` in a different way to achieve this.
```{r}
mortality_df %>%
  filter(region != "NE") %>%
  anti_join(states_df,., by = c("value" = "state") )
  
```


8. Examine the following data sets (the first is `df1` and the second is `df2`) and then, without running any code, answer the following questions. (You can check your answer using code, but try it "by hand" first!)

```{r, echo = TRUE, results = "show"}
df1 <- tibble(id = c("A", "B", "C", "E", "F"), xvar = c(1, 2, 3, 1, 2))
df2 <- tibble(id = c("A", "C", "D", "E", "G", "H"), yvar = c(2, 1, 2, 1, 1, 4))
```

a. How many rows would be in the data set from `left_join(df1, df2, by = c("id" = "id"))`?
    - There should be 5 rows
```{r}
left_join(df1, df2, by = c("id" = "id"))
```
    

b. How many rows would be in the data set from `left_join(df2, df1, by = c("id" = "id"))`?
    - There should be 6 rows in this one too
    
```{r}
left_join(df2, df1, by = c("id" = "id"))
```

c. How many rows would be in the data set from `full_join(df1, df2, by = c("id" = "id"))`?
    - There would be 8 rows because these are being combined by id and there are 8 different ids
```{r}
full_join(df1, df2, by = c("id" = "id"))
```

d. How many rows would be in the data set from `inner_join(df1, df2, by = c("id" = "id"))`?
    - there should be 3 rows because that is how many of the ids match between the two dataframes
```{r}
inner_join(df1, df2, by = c("id" = "id"))
```
    
e. How many rows would be in the data set from `semi_join(df1, df2, by = c("id" = "id"))`?
    - there should be three rows in this one too because the semi_join will return the matches in df1 that are also shown in df2
```{r}
semi_join(df1, df2, by = c("id" = "id"))
```
    
f. How many rows would be in the data set from `anti_join(df1, df2, by = c("id" = "id"))`?
    - this would return 2 rows because it will only report the values in df1 that do not have a match in df2. 
    
```{r}
anti_join(df1, df2, by = c("id" = "id"))
```

